<html><head><title>[unipot] 2 The GAP Package Unipot</title></head>
<body text="#000000" bgcolor="#ffffff">
[<a href = "chapters.htm">Up</a>] [<a href ="CHAP001.htm">Previous</a>] [<a href = "theindex.htm">Index</a>]
<h1>2 The GAP Package Unipot</h1><p>
<P>
<H3>Sections</H3>
<oL>
<li> <A HREF="CHAP002.htm#SECT001">General functionality</a>
<li> <A HREF="CHAP002.htm#SECT002">Unipotent subgroups of Chevalley groups</a>
<li> <A HREF="CHAP002.htm#SECT003">Elements of unipotent subgroups of Chevalley groups</a>
<li> <A HREF="CHAP002.htm#SECT004">Symbolic computation</a>
</ol><p>
<p>
This  chapter  describes  the  package  <font face="Gill Sans,Helvetica,Arial">Unipot</font>.  Mainly,  the  package
provides the ability to compute  with  elements of unipotent subgroups of
Chevalley groups, but also some properties of this groups.
<p>
In this chapter we will refer to unipotent subgroups of Chevalley  groups
as ``unipotent  subgroups'' and  to elements  of unipotent  subgroups  as
``unipotent   elements''.  Specifically,   we  only  consider   unipotent
subgroups generated by all positive root elements.
<p>
<p>
<h2><a name="SECT001">2.1 General functionality</a></h2>
<p><p>
In this section we  will  describe the  general functionality provided by
this package.
<p>
<a name = "SSEC001.1"></a>
<li><code>UnipotChevInfo V</code>
<p>
<code>UnipotChevInfo</code>  is an <code>InfoClass</code> used  in this package. <code>InfoLevel</code> of
this <code>InfoClass</code> is set to  1 by default and can be changed to  any level
by <code>SetInfoLevel( UnipotChevInfo, </code><var>n</var><code> )</code>.
<p>
Following levels are used throughout the package:
<dl compact>
<ol type=1>
<li>
    ---
<li>
    When calculating the order of a finite unipotent subgroup,  the power
    presentation of this number is printed.
    (See <a href="CHAP002.htm#SSEC002.5">Size!for `UnipotChevSubGr'</a> for an example)
<li>
    When  comparing  unipotent  elements,  output,  for which of them the
    canonical form must be computed.
    (See <a href="CHAP002.htm#SSEC003.11">Equality!for UnipotChevElem</a> for an example)
<li>
    ---
<li>
    While calculating the canonical form, output the different steps.
<li>
    The  process  of  calculating  the  Chevalley commutator constants is
    printed on the screen
</dl></dl>
<p>
<p>
<h2><a name="SECT002">2.2 Unipotent subgroups of Chevalley groups</a></h2>
<p><p>
In this section we will describe the functionality for unipotent
subgroups provided by this package.
<p>
<a name = "SSEC002.1"></a>
<li><code>IsUnipotChevSubGr( </code><var>grp</var><code> ) C</code>
<p>
Category for unipotent subgroups.
<p>
<a name = "SSEC002.2"></a>
<li><code>UnipotChevSubGr( </code><var>type</var><code>, </code><var>n</var><code>, </code><var>F</var><code> ) F</code>
<p>
<code>UnipotChevSubGr</code>  returns  the  unipotent  subgroup <i>U</i> of the Chevalley
group of type <var>type</var>, rank <var>n</var> over the ring <var>F</var>.
<p>
<var>type</var> must be one of <code>"A"</code>, <code>"B"</code>, <code>"C"</code>, <code>"D"</code>, <code>"E"</code>, <code>"F"</code>, <code>"G"</code>.
<p>
For the type  <code>"A"</code>, <var>n</var> must be a positive integer.
<p>
For the types <code>"B"</code> and <code>"C"</code>, <var>n</var> must be a positive integer  &#8805; 2.
<p>
For the type  <code>"D"</code>, <var>n</var> must be a positive integer  &#8805; 4.
<p>
For the type  <code>"E"</code>, <var>n</var> must be one of 6, 7, 8.
<p>
For the type  <code>"F"</code>, <var>n</var> must be 4.
<p>
For the type  <code>"G"</code>, <var>n</var> must be 2.
<p>
<pre>
gap&gt; U_G2 := UnipotChevSubGr("G", 2, Rationals);
&lt;Unipotent subgroup of a Chevalley group of type G2 over Rationals&gt;
gap&gt; IsUnipotChevSubGr(U_G2);
true
</pre>
<pre>
gap&gt; UnipotChevSubGr("E", 3, Rationals);
Error, &lt;n&gt; must be one of 6, 7, 8 for type E  called from
UnipotChevFamily( type, n, F ) called from
&lt;function&gt;( &lt;arguments&gt; ) called from read-eval-loop
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can 'return;' to continue
brk&gt;
</pre>
<p>
<a name = "SSEC002.3"></a>
<li><code>PrintObj( </code><var>U</var><code> ) M</code>
<a name = "SSEC002.3"></a>
<li><code>ViewObj( </code><var>U</var><code> ) M</code>
<p>
Special methods for unipotent  subgroups.  (see  <font face="Gill Sans,Helvetica,Arial">GAP</font> Reference Manual,
section  <a href="https://www.gap-system.org/Manuals/doc/ref/chap6.html#X8074A8387C9DB9A8">View  and  Print</a>  for general  information  on <code>View</code>  and
<code>Print</code>)
<p>
<pre>
gap&gt; Print(U_G2);
UnipotChevSubGr( "G", 2, Rationals )gap&gt; View(U_G2);
&lt;Unipotent subgroup of a Chevalley group of type G2 over Rationals&gt;gap&gt;
</pre>
<p>
<a name = "SSEC002.4"></a>
<li><code>One( </code><var>U</var><code> ) M</code>
<a name = "SSEC002.4"></a>
<li><code>OneOp( </code><var>U</var><code> ) M</code>
<p>
Special  methods  for unipotent  subgroups. Return the  identity
element   of   the   group  <var>U</var>.   The   returned   element  has
representation <code>UNIPOT_DEFAULT_REP</code> (see <a href="CHAP002.htm#SSEC003.3">UNIPOT_DEFAULT_REP</a>).
<p>
<a name = "SSEC002.5"></a>
<li><code>Size( </code><var>U</var><code> ) M</code>
<p>
<code>Size</code> returns  the order  of a unipotent subgroup.  This  is  a
special  method for  unipotent  subgroups  using the  result  in
Carter <a href="biblio.htm#Carter72"><cite>Carter72</cite></a>, Theorem 5.3.3 (ii).
<p>
<pre>
gap&gt; SetInfoLevel( UnipotChevInfo, 2 );
gap&gt; Size( UnipotChevSubGr("E", 8, GF(7)) );
#I  The order of this group is 7^120 which is
25808621098934927604791781741317238363169114027609954791128059842592785343731\
7437263620645695945672001
gap&gt; SetInfoLevel( UnipotChevInfo, 1 );
</pre>
<p>
<a name = "SSEC002.6"></a>
<li><code>RootSystem( </code><var>U</var><code> ) M</code>
<p>
This  method is similar  to the  method <code>RootSystem</code>  for semisimple  Lie
algebras (see Section <a href="https://www.gap-system.org/Manuals/doc/ref/chap64.html#X83F829017D46C544">Semisimple  Lie Algebras and Root  Systems</a> in
the <font face="Gill Sans,Helvetica,Arial">GAP</font> Reference Manual for further information).
<p>
<code>RootSystem</code> returns the underlying root system of the unipotent subgroup
<var>U</var>. The returned object is from the category <code>IsRootSystem</code>:
<p>
<pre>
gap&gt; R_G2 := RootSystem(U_G2);
&lt;root system of rank 2&gt;
gap&gt; IsRootSystem(last);
true
gap&gt; SimpleSystem(R_G2);
[ [ 2, -1 ], [ -3, 2 ] ]
gap&gt;
</pre>
<p>
Additionally to the properties and attributes described in the  Reference
Manual, following attributes  are installed for the  Root  Systems by the
package <font face="Gill Sans,Helvetica,Arial">Unipot</font>:
<p>
<a name = "SSEC002.7"></a>
<li><code>PositiveRootsFC( </code><var>R</var><code> ) A</code>
<a name = "SSEC002.7"></a>
<li><code>NegativeRootsFC( </code><var>R</var><code> ) A</code>
<p>
The list of positive resp. negative  roots of the root system <var>R</var>.  Every
root is  represented as a list of coefficients  of the linear combination
in fundamental  roots. E.g.  let  <i>r</i>=&#8721;<sub><i>i</i>=1</sub><sup><i>l</i></sup> <i>k</i><sub><i>i</i></sub><i>r</i><sub><i>i</i></sub>,  where  <i>r</i><sub>1</sub>, ..., <i>r</i><sub><i>l</i></sub> are the  fundamental roots,  then  <i>r</i> is represented as  the
list [<i>k</i><sub>1</sub>, ..., <i>k</i><sub><i>l</i></sub>].
<p>
<pre>
gap&gt; U_E6 := UnipotChevSubGr("E",6,GF(2));
&lt;Unipotent subgroup of a Chevalley group of type E6 over GF(2)&gt;
gap&gt; R_E6 := RootSystem(U_E6);
&lt;root system of rank 6&gt;
gap&gt; PositiveRoots(R_E6){[1..6]};
[ [ 2,  0, -1, 0,  0, 0 ], [ 0, 2, 0, -1, 0,  0 ], [ -1, 0, 2, -1,  0, 0 ],
  [ 0, -1, -1, 2, -1, 0 ], [ 0, 0, 0, -1, 2, -1 ], [  0, 0, 0,  0, -1, 2 ] ]
gap&gt; PositiveRootsFC(R_E6){[1..6]};
[ [ 1, 0, 0, 0, 0, 0 ], [ 0, 1, 0, 0, 0, 0 ], [ 0, 0, 1, 0, 0, 0 ],
  [ 0, 0, 0, 1, 0, 0 ], [ 0, 0, 0, 0, 1, 0 ], [ 0, 0, 0, 0, 0, 1 ] ]
gap&gt;
gap&gt; PositiveRootsFC(R)[Length(PositiveRootsFC(R_E6))]; # the highest root
[ 1, 2, 2, 3, 2, 1 ]
</pre>
<p>
<a name = "SSEC002.8"></a>
<li><code>GeneratorsOfGroup( </code><var>U</var><code> ) M</code>
<p>
This  is a special Method  for unipotent  subgroups of  finite  Chevalley
groups.
<p>
<a name = "SSEC002.9"></a>
<li><code>Representative( </code><var>U</var><code> ) M</code>
<p>
This method  returns  an  element  of  the  unipotent  subgroup  <var>U</var> with
indeterminates  instead of ring elements. Such  an element could be  used
for  symbolic  computations (see  <a href="CHAP002.htm#SECT004">Symbolic Computation</a>).  The  returned
element      has       representation      <code>UNIPOT_DEFAULT_REP</code>      (see
<a href="CHAP002.htm#SSEC003.3">UNIPOT_DEFAULT_REP</a>).
<p>
<pre>
gap&gt; Representative(U_G2);
x_{1}( t_1 ) * x_{2}( t_2 ) * x_{3}( t_3 ) * x_{4}( t_4 ) * 
x_{5}( t_5 ) * x_{6}( t_6 )
</pre>
<p>
<a name = "SSEC002.10"></a>
<li><code>CentralElement( </code><var>U</var><code> ) M</code>
<p>
This  method  returns  the  representative of  the  center of <var>U</var> without
calculating the center.
<p>
<p>
<h2><a name="SECT003">2.3 Elements of unipotent subgroups of Chevalley groups</a></h2>
<p><p>
In this section we will describe the functionality for unipotent elements
provided by this package.
<p>
<a name = "SSEC003.1"></a>
<li><code>IsUnipotChevElem( </code><var>elm</var><code> ) C</code>
<p>
Category for elements of a unipotent subgroup.
<p>
<a name = "SSEC003.2"></a>
<li><code>IsUnipotChevRepByRootNumbers( </code><var>elm</var><code> ) R</code>
<a name = "SSEC003.2"></a>
<li><code>IsUnipotChevRepByFundamentalCoeffs( </code><var>elm</var><code> ) R</code>
<a name = "SSEC003.2"></a>
<li><code>IsUnipotChevRepByRoots( </code><var>elm</var><code> ) R</code>
<p>
<code>IsUnipotChevRepByRootNumbers</code>, <code>IsUnipotChevRepByFundamentalCoeffs</code>  and
<code>IsUnipotChevRepByRoots</code>  are  different  representations  for  unipotent
elements.
<p>
Roots of elements with representation <code>IsUnipotChevRepByRootNumbers</code>  are
represented       by       their       numbers       (positions)       in
<code>PositiveRoots(RootSystem(</code><var>U</var><code>))</code>.
<p>
Roots          of          elements          with          representation
<code>IsUnipotChevRepByFundamentalCoeffs</code>  are  represented  by   elements  of
<code>PositiveRootsFC(RootSystem(</code><var>U</var><code>))</code>.
<p>
Roots  of   elements  with  representation  <code>IsUnipotChevRepByRoots</code>  are
represented     by     roots     themself,      i.e.      elements     of
<code>PositiveRoots(RootSystem(</code><var>U</var><code>))</code>.
<p>
(See  <a href="CHAP002.htm#SSEC003.4">UnipotChevElemByRootNumbers</a>,  <a href="CHAP002.htm#SSEC003.5">UnipotChevElemByFundamentalCoeffs</a>
and <a href="CHAP002.htm#SSEC003.6">UnipotChevElemByRoots</a> for examples.)
<p>
<a name = "SSEC003.3"></a>
<li><code>UNIPOT_DEFAULT_REP V</code>
<p>
This variable  contains  the  default representation  for  newly  created
elements, e.g. created by  <code>One</code> or <code>Random</code>. When  <font face="Gill Sans,Helvetica,Arial">Unipot</font>  is loaded,
the  default representation is  <code>IsUnipotChevRepByRootNumbers</code> and can be
changed by assigning a new value to <code>UNIPOT_DEFAULT_REP</code>.
<p>
<pre>
gap&gt; UNIPOT_DEFAULT_REP := IsUnipotChevRepByFundamentalCoeffs;;
</pre>
<p>
<strong>Note</strong> that <font face="Gill Sans,Helvetica,Arial">Unipot</font> doesn't check the type of this  value, i.e. you may
assign any value to <code>UNIPOT_DEFAULT_REP</code>, which  may  result in errors in
following commands:
<p>
<pre>
gap&gt; UNIPOT_DEFAULT_REP := 3;;
gap&gt; One( U_G2 );
... Error message ...
</pre>
<p>
<a name = "SSEC003.4"></a>
<li><code>UnipotChevElemByRootNumbers( </code><var>U</var><code>, </code><var>roots</var><code>, </code><var>felems</var><code> ) O</code>
<li><code>UnipotChevElemByRootNumbers( </code><var>U</var><code>, </code><var>root</var><code>, </code><var>felem</var><code> ) O</code>
<a name = "SSEC003.4"></a>
<li><code>UnipotChevElemByRN( </code><var>U</var><code>, </code><var>roots</var><code>, </code><var>felems</var><code> ) O</code>
<li><code>UnipotChevElemByRN( </code><var>U</var><code>, </code><var>root</var><code>, </code><var>felem</var><code> ) O</code>
<p>
<code>UnipotChevElemByRootNumbers</code> returns  an element of a unipotent subgroup
<var>U</var>    with    representation    <code>IsUnipotChevRepByRootNumbers</code>    (see
<a href="CHAP002.htm#SSEC003.2">IsUnipotChevRepByRootNumbers</a>).
<p>
<var>roots</var> should be a list of root numbers, i.e. integers from the range 1,
...,  <code>Length(PositiveRoots(RootSystem(</code><var>U</var><code>)))</code>. And <var>felems</var> a list  of
corresponding ring elements or indeterminates over that ring  (see <font face="Gill Sans,Helvetica,Arial">GAP</font>
Reference   Manual,   <a href="https://www.gap-system.org/Manuals/doc/ref/chap66.html#X79D0380D7FA39F7D">Indeterminate</a>  for  general   information  on
indeterminates  or  section  <a href="CHAP002.htm#SECT004">Symbolic computation</a>  of  this  manual for
examples).
<p>
The second  variant of  <code>UnipotChevElemByRootNumbers</code>  is an abbreviation
for the first one if <var>roots</var> and <var>felems</var> contain only one element.
<p>
<code>UnipotChevElemByRN</code> is just a synonym for <code>UnipotChevElemByRootNumbers</code>.
<p>
<pre>
gap&gt; IsIdenticalObj( UnipotChevElemByRN, UnipotChevElemByRootNumbers );
true
gap&gt; y := UnipotChevElemByRootNumbers(U_G2, [1,5], [2,7] );
x_{1}( 2 ) * x_{5}( 7 )
gap&gt; x := UnipotChevElemByRootNumbers(U_G2, 1, 2);
x_{1}( 2 )
</pre>
<p>
In this example we create two elements: <i>x</i><sub><i>r</i><sub>1</sub></sub>( 2 ) &#183;<i>x</i><sub><i>r</i><sub>5</sub></sub>( 7 ) and
<i>x</i><sub><i>r</i><sub>1</sub></sub>( 2 ), where <i>r</i><sub><i>i</i></sub>, <i>i</i> = 1, ..., 6 are the positive roots in
<code>PositiveRoots(RootSystem(</code><var>U</var><code>))</code> and <i>x</i><sub><i>r</i><sub><i>i</i></sub></sub>(<i>t</i>), <i>i</i> = 1, ..., 6  the
corresponding root elements.
<p>
<a name = "SSEC003.5"></a>
<li><code>UnipotChevElemByFundamentalCoeffs( </code><var>U</var><code>, </code><var>roots</var><code>, </code><var>felems</var><code> ) O</code>
<li><code>UnipotChevElemByFundamentalCoeffs( </code><var>U</var><code>, </code><var>root</var><code>, </code><var>felem</var><code> ) O</code>
<a name = "SSEC003.5"></a>
<li><code>UnipotChevElemByFC( </code><var>U</var><code>, </code><var>roots</var><code>, </code><var>felems</var><code> ) O</code>
<li><code>UnipotChevElemByFC( </code><var>U</var><code>, </code><var>root</var><code>, </code><var>felem</var><code> ) O</code>
<p>
<code>UnipotChevElemByFundamentalCoeffs</code>  returns  an  element  of a unipotent
subgroup  <var>U</var>  with  representation  <code>IsUnipotChevRepByFundamentalCoeffs</code>
(see <a href="CHAP002.htm#SSEC003.2">IsUnipotChevRepByFundamentalCoeffs</a>).
<p>
<var>roots</var>      should      be      a     list      of      elements      of
<code>PositiveRootsFC(RootSystem(</code><var>U</var><code>))</code>.   And   <var>felems</var>    a    list    of
corresponding ring elements or indeterminates over that ring  (see <font face="Gill Sans,Helvetica,Arial">GAP</font>
Reference   Manual,   <a href="https://www.gap-system.org/Manuals/doc/ref/chap66.html#X79D0380D7FA39F7D">Indeterminate</a>  for  general   information  on
indeterminates  or  section  <a href="CHAP002.htm#SECT004">Symbolic computation</a>  of  this  manual for
examples).
<p>
The   second   variant  of   <code>UnipotChevElemByFundamentalCoeffs</code>   is  an
abbreviation for  the first one if <var>roots</var> and  <var>felems</var> contain only one
element.
<p>
<code>UnipotChevElemByFC</code>       is       just       a        synonym       for
<code>UnipotChevElemByFundamentalCoeffs</code>.
<p>
<pre>
gap&gt; PositiveRootsFC(RootSystem(U_G2));
[ [ 1, 0 ], [ 0, 1 ], [ 1, 1 ], [ 2, 1 ], [ 3, 1 ], [ 3, 2 ] ]
gap&gt; y1 := UnipotChevElemByFundamentalCoeffs( U_G2, [[ 1, 0 ], [ 3, 1 ]], [2,7] );
x_{[ 1, 0 ]}( 2 ) * x_{[ 3, 1 ]}( 7 )
gap&gt; x1 := UnipotChevElemByFundamentalCoeffs( U_G2, [ 1, 0 ], 2 );
x_{[ 1, 0 ]}( 2 )
</pre>
<p>
In   this   example   we   create   the   same   two   elements   as   in
<a href="CHAP002.htm#SSEC003.4">UnipotChevElemByRootNumbers</a>: <i>x</i><sub>[ 1, 0 ]</sub>( 2 ) &#183;<i>x</i><sub>[ 3, 1 ]</sub>( 7 )
and <i>x</i><sub>[ 1, 0 ]</sub>( 2 ), where [ 1, 0 ] = 1<i>r</i><sub>1</sub> + 0<i>r</i><sub>2</sub> = <i>r</i><sub>1</sub> and [ 3, 1 ] = 3<i>r</i><sub>1</sub> + 1<i>r</i><sub>2</sub>=<i>r</i><sub>5</sub>  are  the  first  and the  fifth  positive roots of
<code>PositiveRootsFC(RootSystem(</code><var>U</var><code>))</code> respectively.
<p>
<a name = "SSEC003.6"></a>
<li><code>UnipotChevElemByRoots( </code><var>U</var><code>, </code><var>roots</var><code>, </code><var>felems</var><code> ) O</code>
<li><code>UnipotChevElemByRoots( </code><var>U</var><code>, </code><var>root</var><code>, </code><var>felem</var><code> ) O</code>
<a name = "SSEC003.6"></a>
<li><code>UnipotChevElemByR( </code><var>U</var><code>, </code><var>roots</var><code>, </code><var>felems</var><code> ) O</code>
<li><code>UnipotChevElemByR( </code><var>U</var><code>, </code><var>root</var><code>, </code><var>felem</var><code> ) O</code>
<p>
<code>UnipotChevElemByRoots</code> returns  an element of  a unipotent  subgroup <var>U</var>
with         representation        <code>IsUnipotChevRepByRoots</code>        (see
<a href="CHAP002.htm#SSEC003.2">IsUnipotChevRepByRoots</a>).
<p>
<var>roots</var>   should   be   a    list   of   elements   of   <code>PositiveRoots(
or  indeterminates  over   that   ring  (see   <font face="Gill Sans,Helvetica,Arial">GAP</font>  Reference  Manual,
"ref:Indeterminate" for general information on indeterminates or  section
"Symbolic computation" of this manual for examples).
<p>
The second variant of `UnipotChevElemByRoots</code> is an abbreviation  for the
first one if <var>roots</var> and <var>felems</var> contain only one element.
<p>
<code>UnipotChevElemByR</code> is just a synonym for <code>UnipotChevElemByRoots</code>.
<p>
<pre>
gap&gt; PositiveRoots(RootSystem(U_G2));
[ [ 2, -1 ], [ -3, 2 ], [ -1, 1 ], [ 1, 0 ], [ 3, -1 ], [ 0, 1 ] ]
gap&gt; y2 := UnipotChevElemByRoots( U_G2, [[ 2, -1 ], [ 3, -1 ]], [2,7] );
x_{[ 2, -1 ]}( 2 ) * x_{[ 3, -1 ]}( 7 )
gap&gt; x2 := UnipotChevElemByRoots( U_G2, [ 2, -1 ], 2 );
x_{[ 2, -1 ]}( 2 )
</pre>
<p>
In this example we create again the two elements as in previous examples:
<i>x</i><sub>[ 2, &#8722;1 ]</sub>( 2 ) &#183;<i>x</i><sub>[ 3, &#8722;1 ]</sub>( 7 ) and <i>x</i><sub>[ 2, &#8722;1 ]</sub>( 2 ), where
[ 2, &#8722;1 ] = <i>r</i><sub>1</sub>  and [ 3, &#8722;1 ] = <i>r</i><sub>5</sub> are the  first  and the fifth
positive roots of <code>PositiveRoots(RootSystem( </code><var>U</var><code>))</code> respectively.
<p>
<a name = "SSEC003.7"></a>
<li><code>UnipotChevElemByRootNumbers( </code><var>x</var><code> ) O</code>
<a name = "SSEC003.7"></a>
<li><code>UnipotChevElemByFundamentalCoeffs( </code><var>x</var><code> ) O</code>
<a name = "SSEC003.7"></a>
<li><code>UnipotChevElemByRoots( </code><var>x</var><code> ) O</code>
<p>
These three methods are  provided  for converting a unipotent element  to
the respective representation.
<p>
If  <var>x</var>  has  already  the required representation,  then  <var>x</var>  itself is
returned. Otherwise  a <strong>new</strong> element  with the required representation is
generated.
<p>
<pre>
gap&gt; x;
x_{1}( 2 )
gap&gt; x1 := UnipotChevElemByFundamentalCoeffs( x );
x_{[ 1, 0 ]}( 2 )
gap&gt; IsIdenticalObj(x, x1); x = x1;
false
true
gap&gt; x2 := UnipotChevElemByFundamentalCoeffs( x1 );;
gap&gt; IsIdenticalObj(x1, x2);
true
</pre>
<p>
<strong>Note:</strong>  If  some  attributes  of  <var>x</var>  are  known  (e.g  <code>Inverse</code>  (see
<a href="CHAP002.htm#SSEC003.15">Inverse!for     `UnipotChevElem'</a>)      or     <code>CanonicalForm</code>      (see
<a href="CHAP002.htm#SSEC003.8">CanonicalForm</a>)), then they are ``converted'' to the new representation,
too.
<p>
<code>&nbsp;UnipotChevElemByRootNumbers( </code><var>U</var><code>, </code><var>list</var><code> ) O</code>
<br><code>&nbsp;UnipotChevElemByRoots( </code><var>U</var><code>, </code><var>list</var><code> ) O</code>
<br><code>&nbsp;UnipotChevElemByFundamentalCoeffs( </code><var>U</var><code>, </code><var>list</var><code> ) O</code>
<p>
<strong>DEPRECATED</strong>  These   are  old  versions  of  <code>UnipotChevElemByXX</code>  (from
<font face="Gill Sans,Helvetica,Arial">Unipot</font>  1.0   and  1.1).  They  are  deprecated  now  and   exist  for
compatibility only. They may be removed at any time.
<p>
<a name = "SSEC003.8"></a>
<li><code>CanonicalForm( </code><var>x</var><code> ) A</code>
<p>
<code>CanonicalForm</code>  returns the  canonical form of <var>x</var>. For more information
on the canonical form  see Carter <a href="biblio.htm#Carter72"><cite>Carter72</cite></a>, Theorem 5.3.3 (ii). It
says:
<p>
Each  element of  a unipotent subgroup <i>U</i> of a Chevalley group with root
system &#934; is uniquely expressible in the form
<br clear="all" /><table border="0" width="100%"><tr><td><table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center"> </td><td nowrap="nowrap" align="center"><small></small><!--sup--><br /><font size="+3">&#8719;<br /></font><small><i>r</i><sub><i>i</i></sub> &#8712; &#934;<sup>+</sup></small>&nbsp;<br /></td><td nowrap="nowrap" align="center"><i>x</i><sub><i>r</i><sub><i>i</i></sub></sub>(<i>t</i><sub><i>i</i></sub>), </td></tr></table></td></tr></table>
where the product is taken over all positive roots in increasing order.
<p>
<pre>
gap&gt; z := UnipotChevElemByFC( U_G2, [[0,1], [1,0]], [3,2]);
x_{[ 0, 1 ]}( 3 ) * x_{[ 1, 0 ]}( 2 )
gap&gt; CanonicalForm(z);
x_{[ 1, 0 ]}( 2 ) * x_{[ 0, 1 ]}( 3 ) * x_{[ 1, 1 ]}( 6 ) *
x_{[ 2, 1 ]}( 12 ) * x_{[ 3, 1 ]}( 24 ) * x_{[ 3, 2 ]}( -72 )
</pre>
<p>
So  if  we  call  the  positive  roots  <i>r</i><sub>1</sub>,...,<i>r</i><sub>6</sub>,  we  have   <i>z</i> = <i>x</i><sub><i>r</i><sub>2</sub></sub>(3)<i>x</i><sub><i>r</i><sub>1</sub></sub>(2) = <i>x</i><sub><i>r</i><sub>1</sub></sub>( 2 ) <i>x</i><sub><i>r</i><sub>2</sub></sub>( 3 ) <i>x</i><sub><i>r</i><sub>3</sub></sub>( 6 ) <i>x</i><sub><i>r</i><sub>4</sub></sub>( 12 ) <i>x</i><sub><i>r</i><sub>5</sub></sub>( 24 ) <i>x</i><sub><i>r</i><sub>6</sub></sub>( &#8722;72 ).
<p>
<a name = "SSEC003.9"></a>
<li><code>PrintObj( </code><var>x</var><code> ) M</code>
<a name = "SSEC003.9"></a>
<li><code>ViewObj( </code><var>x</var><code> ) M</code>
<p>
Special  methods for  unipotent elements. (see <font face="Gill Sans,Helvetica,Arial">GAP</font>  Reference  Manual,
section  <a href="https://www.gap-system.org/Manuals/doc/ref/chap6.html#X8074A8387C9DB9A8">View  and  Print</a>  for  general  information on  <code>View</code> and
<code>Print</code>). The output depends on the representation of <var>x</var>.
<p>
<pre>
gap&gt; Print(x);
UnipotChevElemByRootNumbers( UnipotChevSubGr( "G", 2, Rationals ), \
[ 1 ], [ 2 ] )gap&gt; View(x);
x_{1}( 2 )gap&gt;
</pre>
<pre>
gap&gt; Print(x1);
UnipotChevElemByFundamentalCoeffs( UnipotChevSubGr( "G", 2, Rationals ), \
[ [ 1, 0 ] ], [ 2 ] )gap&gt; View(x1);
x_{[ 1, 0 ]}( 2 )gap&gt;
</pre>
<p>
<a name = "SSEC003.10"></a>
<li><code>ShallowCopy( </code><var>x</var><code> ) M</code>
<p>
This is a special method for unipotent elements.
<p>
<code>ShallowCopy</code>  creates  a  copy  of  <var>x</var>.  The  returned  object is  <strong>not
identical</strong> to <var>x</var> but it  is <strong>equal</strong> to <var>x</var> w.r.t. the  equality operator
<code>=</code>. <strong>Note</strong> that <code>CanonicalForm</code> and  <code>Inverse</code>  of  <var>x</var>  (if known)  are
identical to <code>CanonicalForm</code> and <code>Inverse</code> of the returned object.
<p>
(See <font face="Gill Sans,Helvetica,Arial">GAP</font> Reference  Manual,  section <a href="https://www.gap-system.org/Manuals/doc/ref/chap12.html#X786B942B82D684BD">Duplication of Objects</a>  for
further information on copyability)
<p>
<a name = "SSEC003.11"></a>
<li><code></code><var>x</var><code> = </code><var>y</var><code> M</code>
<a name = "I0"></a>

<p>
Special  method  for unipotent elements. If <var>x</var> and <var>y</var> are identical  or
are  products of  the  <strong>same</strong> root  elements  then  <code>true</code>  is  returned.
Otherwise <code>CanonicalForm</code> (see <a href="CHAP002.htm#SSEC003.8">CanonicalForm</a>) of both arguments must be
computed (if not already known), which may be expensive. If the canonical
form of one  of  the  elements  must be  calculated  and  <code>InfoLevel</code>  of
<code>UnipotChevInfo</code> is at least 3, the user is notified about this:
<p>
<pre>
gap&gt; y := UnipotChevElemByRN( U_G2, [1,5], [2,7] );
x_{1}( 2 ) * x_{5}( 7 )
gap&gt; z := UnipotChevElemByRN( U_G2, [5,1], [7,2] );
x_{5}( 7 ) * x_{1}( 2 )
gap&gt; SetInfoLevel( UnipotChevInfo, 3 );
gap&gt; y=z;
#I  CanonicalForm for the 1st argument is not known.
#I                    computing it may take a while.
#I  CanonicalForm for the 2nd argument is not known.
#I                    computing it may take a while.
true
gap&gt; SetInfoLevel( UnipotChevInfo, 1 );
</pre>
<p>
<a name = "SSEC003.12"></a>
<li><code></code><var>x</var><code> &lt; </code><var>y</var><code> M</code>
<a name = "I1"></a>

<p>
Special Method for <code>UnipotChevElem</code>
<p>
This is needed e.g. by <code>AsSSortetList</code>.
<p>
The ordering is computed in the following way:
Let    <i>x</i> = <i>x</i><sub><i>r</i><sub>1</sub></sub>(<i>s</i><sub>1</sub>) &#183;.&#183;<i>x</i><sub><i>r</i><sub><i>n</i></sub></sub>(<i>s</i><sub><i>n</i></sub>)
and    <i>y</i> = <i>x</i><sub><i>r</i><sub>1</sub></sub>(<i>t</i><sub>1</sub>) &#183;.&#183;<i>x</i><sub><i>r</i><sub><i>n</i></sub></sub>(<i>t</i><sub><i>n</i></sub>), then
<p>
<br clear="all" /><table border="0" width="100%"><tr><td><table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center"> <i>x</i>  &lt;  <i>y</i> &nbsp;&nbsp;&nbsp; &#8660; &nbsp;&nbsp;&nbsp; [ <i>s</i><sub>1</sub>, ..., <i>s</i><sub><i>n</i></sub> ]  &lt;  [ <i>t</i><sub>1</sub>, ..., <i>t</i><sub><i>n</i></sub> ], </td></tr></table></td></tr></table>
<p>
where the lists are compared lexicographically.
e.g. for <i>x</i> = <i>x</i><sub><i>r</i><sub>1</sub></sub>(1)<i>x</i><sub><i>r</i><sub>2</sub></sub>(1) = <i>x</i><sub><i>r</i><sub>1</sub></sub>(1)<i>x</i><sub><i>r</i><sub>2</sub></sub>(1)<i>x</i><sub><i>r</i><sub>3</sub></sub>(0)  (field elems: <code>[ 1, 1, 0 ]</code>)
     and <i>y</i> = <i>x</i><sub><i>r</i><sub>1</sub></sub>(1)<i>x</i><sub><i>r</i><sub>3</sub></sub>(1) = <i>x</i><sub><i>r</i><sub>1</sub></sub>(1)<i>x</i><sub><i>r</i><sub>2</sub></sub>(0)<i>x</i><sub><i>r</i><sub>3</sub></sub>(1)  (field elems: <code>[ 1, 0, 1 ]</code>)
we have <i>y</i>  &lt;  <i>x</i> (above lists ordered lexicographically).
<p>
<a name = "SSEC003.13"></a>
<li><code></code><var>x</var><code> * </code><var>y</var><code> M</code>
<a name = "I2"></a>

<p>
Special  method  for unipotent  elements.  The  expressions  in the  form
<i>x</i><sub><i>r</i></sub>(<i>t</i>)<i>x</i><sub><i>r</i></sub>(<i>u</i>) will be reduced to <i>x</i><sub><i>r</i></sub>(<i>t</i>+<i>u</i>) whenever possible.
<p>
<pre>
gap&gt; y;z;
x_{1}( 2 ) * x_{5}( 7 )
x_{5}( 7 ) * x_{1}( 2 )
gap&gt; y*z;
x_{1}( 2 ) * x_{5}( 14 ) * x_{1}( 2 )
</pre>
<p>
<strong>Note:</strong>  The   representation  of  the   product  will   be  always   the
representation of the first argument.
<p>
<pre>
gap&gt; x; x1; x=x1;
x_{1}( 2 )
x_{[ 1, 0 ]}( 2 )
true
gap&gt; x * x1;
x_{1}( 4 )
gap&gt; x1 * x;
x_{[ 1, 0 ]}( 4 )
</pre>
<p>
<a name = "SSEC003.14"></a>
<li><code>OneOp( </code><var>x</var><code> ) M</code>
<p>
Special method for unipotent elements. <code>OneOp</code> returns the multiplicative
neutral element of <var>x</var>. This is equal to <code></code><var>x</var><code>^0</code>.
<p>
<a name = "SSEC003.15"></a>
<li><code>Inverse( </code><var>x</var><code> ) M</code>
<a name = "SSEC003.15"></a>
<li><code>InverseOp( </code><var>x</var><code> ) M</code>
<p>
Special methods for unipotent elements. We are using the fact
<br clear="all" /><table border="0" width="100%"><tr><td><table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center"> </td><td align="left" class="cl">&#x239B;<br />&#x239D;</td><td nowrap="nowrap" align="center"><i>x</i><sub><i>r</i><sub>1</sub></sub>( <i>t</i><sub>1</sub>) &#183;&#183;&#183;<i>x</i><sub><i>r</i><sub><i>m</i></sub></sub>(<i>t</i><sub><i>m</i></sub>) </td><td align="left" class="cl">&#x239E;<br />&#x23A0;</td><td nowrap="nowrap" align="center"><small>&#8722;1</small><!--sup--><br /><small></small>&nbsp;<br /></td><td nowrap="nowrap" align="center"> = <i>x</i><sub><i>r</i><sub><i>m</i></sub></sub>(&#8722;<i>t</i><sub><i>m</i></sub>) &#183;&#183;&#183;<i>x</i><sub><i>r</i><sub>1</sub></sub>(&#8722;<i>t</i><sub>1</sub>) . </td></tr></table></td></tr></table>
<p>
<a name = "SSEC003.16"></a>
<li><code>IsOne( </code><var>x</var><code> ) M</code>
<p>
Special method for unipotent elements. Returns <code>true</code>  if and only if <var>x</var>
is equal to the identity element.
<p>
<a name = "SSEC003.17"></a>
<li><code></code><var>x</var><code> ^ </code><var>i</var><code> M</code>
<p>
Integral powers of the unipotent elements are  calculated  by the default
methods installed in <font face="Gill Sans,Helvetica,Arial">GAP</font>.  But  special (more efficient)  methods  are
instlled for root elements and for the identity.
<p>
<a name = "SSEC003.18"></a>
<li><code></code><var>x</var><code> ^ </code><var>y</var><code> M</code>
<p>
Conjugation  of  two  unipotent elements,  i.e.  <i>x</i><sup><i>y</i></sup> = <i>y</i><sup>&#8722;1</sup><i>xy</i>.  The
representation of  the result  will  be the representation  of <var>x</var>.
<p>
<a name = "SSEC003.19"></a>
<li><code>Comm( </code><var>x</var><code>, </code><var>y</var><code> ) M</code>
<li><code>Comm( </code><var>x</var><code>, </code><var>y</var><code>, "canonical" ) M</code>
<p>
Special methods for unipotent elements.
<p>
<code>Comm</code> returns the commutator of <var>x</var> and <var>y</var>, i.e. <i>x</i>  <sup>&#8722;1</sup> &#183;<i>y</i> <sup>&#8722;1</sup> &#183;<i>x</i>  &#183;<i>y</i> . The  second variant returns  the  canonical form  of the
commutator.  In some cases it may be more efficient  than <code>CanonicalForm(
Comm( </code><var>x</var><code>, </code><var>y</var><code> ) )</code>
<p>
<a name = "SSEC003.20"></a>
<li><code>IsRootElement( </code><var>x</var><code> ) P</code>
<p>
<code>IsRootElement</code>  returns  <code>true</code>  if  and  only  if  <var>x</var>  is a <em>root</em>
element, i.e. <i>x</i> =<i>x</i><sub><i>r</i></sub>(<i>t</i>) for some root <i>r</i>. We  store this property
immediately after creating objects.
<p>
<strong>Note:</strong> the canonical form of <var>x</var> may be a root element even if <var>x</var> isn't
one.
<p>
<pre>
gap&gt; x := UnipotChevElemByRN( U_G2, [1,5,1], [2,7,-2] );
x_{1}( 2 ) * x_{5}( 7 ) * x_{1}( -2 )
gap&gt; IsRootElement(x);
false
gap&gt; CanonicalForm(x); IsRootElement(CanonicalForm(x));
x_{5}( 7 )
true
</pre>
<p>
<a name = "SSEC003.21"></a>
<li><code>IsCentral( </code><var>U</var><code>, </code><var>z</var><code> )</code>
<p>
Special method for a unipotent subgroup and a unipotent element.
<p>
<p>
<h2><a name="SECT004">2.4 Symbolic computation</a></h2>
<p><p>
In  some  cases,  calculation  with explicite  elements  is  not  enough.
<font face="Gill Sans,Helvetica,Arial">Unipot</font>  povides a  way  to  do  symbolic calculations  with  unipotent
elements for this  purpose.  This is  done by using  indeterminates  (see
<font face="Gill Sans,Helvetica,Arial">GAP</font> Reference Manual, <a href="https://www.gap-system.org/Manuals/doc/ref/chap66.html#X7A8FADCD875826DA">Indeterminates</a> for  more information) over
the underlying field instead of the field elements.
<p>
<pre>
gap&gt; U_G2 := UnipotChevSubGr("G", 2, Rationals);;
gap&gt; a := Indeterminate( Rationals, "a" );
a
gap&gt; b := Indeterminate( Rationals, "b", [a] );
b
gap&gt; c := Indeterminate( Rationals, "c", [a,b] );
c
gap&gt; x := UnipotChevElemByFC(U_G2, [ [3,1], [1,0], [0,1] ], [a,b,c] );
x_{[ 3, 1 ]}( a ) * x_{[ 1, 0 ]}( b ) * x_{[ 0, 1 ]}( c )
gap&gt; CanonicalForm(x);
x_{[ 1, 0 ]}( b ) * x_{[ 0, 1 ]}( c ) * x_{[ 3, 1 ]}( a ) *
x_{[ 3, 2 ]}( a*c )
gap&gt; CanonicalForm(x^-1);
x_{[ 1, 0 ]}( -b ) * x_{[ 0, 1 ]}( -c ) * x_{[ 1, 1 ]}( b*c ) *
x_{[ 2, 1 ]}( -b^2*c ) * x_{[ 3, 1 ]}( -a+b^3*c ) * x_{[ 3, 2 ]}( b^3*c^2 )
</pre>
<p>
<p>
[<a href = "chapters.htm">Up</a>] [<a href ="CHAP001.htm">Previous</a>] [<a href = "theindex.htm">Index</a>]
<P>
<address>unipot manual<br>March 2018
</address></body></html>